
;; tuple creation helper
forall X -> tuple unsafe_tuple(X x) asm "NOP";

;; Toncli will automaticly download global_config
;; And pass it to runvm (when running data functions)
;; So you can get actual global config of network from get_config() function
cell get_config() asm "CONFIGROOT";

;; c7 config (if you don't know what it is - just use as is)
tuple get_c7() inline method_id {
    return unsafe_tuple([unsafe_tuple([
        0x076ef1ea,           ;; magic
        0,                    ;; actions
        0,                    ;; msgs_sent
        now(),                ;; unixtime
        1,                    ;; block_lt
        1,                    ;; trans_lt
        239,                  ;; randseed
        unsafe_tuple([1000000000, null()]),  ;; balance_remaining
        my_address(),         ;; myself
        get_config()          ;; global_config
    ])]);
}

cell get_prev_c4() asm "10 GETPARAM UNPAIR DROP";
cell get_prev_c5() asm "10 GETPARAM UNPAIR SWAP DROP";

cell get_extra() asm "c4 PUSH";
() set_extra(cell c) impure asm "c4 POP";


;; prefer using 'invoke_method' or 'invoke_method_expect_fail'
;; (fun, [args] -> (exit_code, gas_used, [return values]))
forall F, A, R -> (int, int, R) invoke_method_full(F fun, A args) impure asm
  "RESETLOADEDCELLS"                 ;; <- make sure first cell load cost 100 gas, not 25
  "GASLIMITSTEMP SWAP DROP ROTREV"   ;; (gas_rem, fun, agrs)
  "255 PUSHINT EXPLODEVAR"           ;; (gas_rem, fun, arg_1, arg_2, ..., arg_n, n)
  "DUP INC ROLLX"                    ;; (gas_rem, arg_1, arg_2, ..., arg_n, n, fun)
  "<{"
    "<{"                             ;; <- normal execution
      "EXECUTE"
      "DEPTH TUPLEVAR"               ;; ([res_1, res_2, ..., res_k])
      "ZERO SWAP"                    ;; (exit_code = 0, [res..])
    "}> PUSHCONT"
    "<{ SWAP DROP NIL }> PUSHCONT"   ;; <- exception handler
    "TRY"
  "}> PUSHCONT"                      ;; (gas_rem, args.., n, fun, func_with_exception_wrapper)
  "ROT INC -1 PUSHINT"               ;; (gas_rem, args.., fun, func_with_exception_wrapper, n + 1, -1)
  "CALLXVARARGS"                     ;; (gas_rem, exit_code, [res..])
  "ROT GASLIMITSTEMP SWAP DROP SUB"  ;; (exit_code, [res..], gas used)
  "SWAP"                             ;; (exit_code, gas_used, [res..])
;

;; same as 'invoke_method_full', but raises if exit_code is not 0 or 1
;; (fun, [args] -> gas_used, [return values])
forall F, A, R -> (int, R) invoke_method(F fun, A args) impure {
    var (int exit_code, int gas_used, return_values) = invoke_method_full(fun, args);
    throw_if(100, (exit_code != 0) & (exit_code != 1));
    return (gas_used, return_values);
}

;; same as 'invoke_method_full', but raises if exit_code is 0 or 1
;; (fun, [args] -> gas_used)
forall F, A -> int invoke_method_expect_fail(F fun, A args) impure {
    var (int exit_code, int gas_used, return_values) = invoke_method_full(fun, args);
    throw_if(100, (exit_code == 0) | (exit_code == 1));
    return gas_used;
}